<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | /home/matstani/weblog]]></title>
  <link href="http://matstani.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://matstani.github.com/"/>
  <updated>2014-03-09T17:07:53+09:00</updated>
  <id>http://matstani.github.com/</id>
  <author>
    <name><![CDATA[Shunsaku MATSUTANI]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Clojure] iTextでPDFファイル作成(ウェブアプリケーション)]]></title>
    <link href="http://matstani.github.com/blog/2013/10/07/try-itext-compojure/"/>
    <updated>2013-10-07T20:52:00+09:00</updated>
    <id>http://matstani.github.com/blog/2013/10/07/try-itext-compojure</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/weavejester/compojure">Compojure</a>ベースのClojureウェブアプリケーションで、<a href="http://itextpdf.com/">iText</a>を利用したPDFファイル出力を行う手順をメモします。(ファイルに保存する例は<a href="/blog/2013/10/07/clojure-itext-japanese/">こちら</a>。)<br/>
例として、SQLiteデータベースから従業員データを読み取り、PDFファイルとして出力することを考えてみます。</p>

<h2>テスト用プロジェクト作成</h2>

<p><code>
$ lein new compojure try-itext-compojure
$ cd try-itext-compojure
</code>
<code>project.clj</code>の<code>:dependencies</code>に<code>[com.itextpdf/itextpdf "5.4.4"]</code> <code>[com.itextpdf/itext-asian "5.2.0"]</code> <code>[org.xerial/sqlite-jdbc "3.7.2"]</code> <code>[korma "0.3.0-RC5"]</code>を追記します。
<code>
$ lein deps
</code></p>

<h2>データベース準備</h2>

<p><code>
$ mkdir db
$ sqlite3 db/try-itext.sqlite3 "CREATE TABLE employees (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)"
$ sqlite3 db/try-itext.sqlite3 "INSERT INTO employees (name) VALUES ('名無 一郎');"
$ sqlite3 db/try-itext.sqlite3 "INSERT INTO employees (name) VALUES ('名無 二郎');"
$ sqlite3 db/try-itext.sqlite3 "INSERT INTO employees (name) VALUES ('名無 三郎');"
</code></p>

<h2>サンプルコード</h2>

<p><a href="https://gist.github.com/matstani/6866740">handler.clj</a>
{% gist 6866740 %}</p>

<h2>起動</h2>

<p><code>
$ lein ring server-headless
</code>
ブラウザでlocalhost:3000にアクセスするとPDFファイルが表示されます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Clojure] iTextでPDFファイル作成]]></title>
    <link href="http://matstani.github.com/blog/2013/10/07/clojure-itext-japanese/"/>
    <updated>2013-10-07T17:16:00+09:00</updated>
    <id>http://matstani.github.com/blog/2013/10/07/clojure-itext-japanese</id>
    <content type="html"><![CDATA[<p>ClojureでPDFファイルを作成するためのライブラリとして<a href="https://github.com/yogthos/clj-pdf">clj-pdf</a>がありますが、そのままでは日本語フォントに対応していないようなので、直接<a href="http://itextpdf.com/">iText</a>を使う手順を紹介します。</p>

<h2>テスト用プロジェクト作成</h2>

<p><code>
$ lein new app try-itext
$ cd try-itext
</code>
<code>project.clj</code>の<code>:dependencies</code>に<code>[com.itextpdf/itextpdf "5.4.4"]</code> <code>[com.itextpdf/itext-asian "5.2.0"]</code>を追記します。
<code>
$ lein deps
</code></p>

<h2>サンプルコード</h2>

<p><a href="https://gist.github.com/matstani/6864398">core.clj</a>
{% gist 6864398 %}</p>

<h2>プログラム実行</h2>

<p><code>
$ lein run
</code>
実行すると、<code>test.pdf</code>が作成されます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Clojure] lein-typed]]></title>
    <link href="http://matstani.github.com/blog/2013/09/04/lein-typed/"/>
    <updated>2013-09-04T17:57:00+09:00</updated>
    <id>http://matstani.github.com/blog/2013/09/04/lein-typed</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/frenchy64/lein-typed">lein-typed</a>を利用すると、<a href="https://github.com/clojure/core.typed">core.typed</a>ライブラリを利用したClojureプログラムの静的型チェックを<a href="https://github.com/technomancy/leiningen">Leiningen</a>タスクとして実行できます。</p>

<h2>インストール</h2>

<h3>全てのプロジェクトで利用する場合</h3>

<p><code>~/.lein/profiles.clj</code>の<code>:user</code> <code>:plugins</code>に<code>[lein-typed "0.3.0"]</code>を追記します。(ファイルが存在しない場合は新規作成)<br/>
例)
<code>
{:user {:plugins [[lein-typed "0.3.0"]]}}
</code></p>

<h3>特定のプロジェクトで利用する場合</h3>

<p><code>project.clj</code>の<code>:plugins</code>に<code>[lein-typed "0.3.0"]</code>を追記します。</p>

<h2>型チェックの実行</h2>

<p><code>project.clj</code>にチェック対象となるnamespaceを記述します。<br/>
例)
```
(defproject try-typed "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
  :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]</p>

<pre><code>             [org.clojure/core.typed "0.2.3"]]
</code></pre>

<p>  :plugins [[lein-typed "0.3.0"]]
  ; 対象namespaceを指定
  :core.typed {:check [try-typed.core]})
<code>
静的型チェックを実行します。
</code>
$ lein typed check
Initializing core.typed ...
"Elapsed time: 11563.779405 msecs"
core.typed initialized.
Start collecting try-typed.core
Finished collecting try-typed.core
Collected 1 namespaces in 11658.922614 msecs
Start checking try-typed.core
Checked try-typed.core in 423.743596 msecs
Checked 1 namespaces (approx. 33 lines) in 12087.276047 msecs
<code>
`check`の替わりに`coverage`を指定すると、型指定annotationの網羅率を表示します。
</code>
lein typed coverage
Initializing core.typed ...
"Elapsed time: 3286.597969 msecs"
core.typed initialized.
Start collecting try-typed.core
Finished collecting try-typed.core
Collected 1 namespaces in 3383.256821 msecs
Checked 0 namespaces (approx. 0 lines) in 3385.801947 msecs
Found 4 annotated vars out of 4 vars
100% var annotation coverage
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Clojure] core.typedで静的型チェック]]></title>
    <link href="http://matstani.github.com/blog/2013/09/03/try-core-typed/"/>
    <updated>2013-09-03T13:25:00+09:00</updated>
    <id>http://matstani.github.com/blog/2013/09/03/try-core-typed</id>
    <content type="html"><![CDATA[<p>Clojureは動的型付けの言語ですが、<a href="https://github.com/clojure/core.typed">core.typed</a>ライブラリを利用すると、静的型チェックを行うことができます。<br/>
<a href="https://groups.google.com/forum/#!msg/clojure-core-typed/U_aA_Ce3qWg/gJWpdflBe4AJ">バージョン0.2.0リリースで、Production Readyとアナウンスされました。</a><br/>
単純な例を試してみたのでメモします。</p>

<h2>テスト用プロジェクト作成</h2>

<p><code>
$ lein new try-typed
$ cd try-typed
</code>
<code>project.clj</code>に<code>[org.clojure/core.typed "0.2.3"]</code>を追記します。
<code>
$ lein deps
</code></p>

<h2>静的型チェックの実行</h2>

<p><code>core.typed</code>を利用した静的型チェックは、プログラムのコンパイルとは別に、明示的に実行します。<br/>
REPL内で<code>clojure.core.typed/check-ns</code>関数を実行することにより、指定したnamespaceをチェックします。</p>

<h3>1. <code>REPL</code>起動</h3>

<p><code>
$ lein repl
</code></p>

<h3>2. 静的型チェック実行</h3>

<p>先ほど作成したテスト用プロジェクトに対し、型チェックを行ってみます。
<code>
user=&gt; (use 'clojure.core.typed)
user=&gt; (check-ns 'try-typed.core)
</code>
上記を実行すると、以下のようにエラーになります。
<code>
Type Error (try-typed.core:3:1) Found untyped var definition: try-typed.core/foo
Hint: Add the annotation for try-typed.core/foo via check-ns or cf
in: (def foo (fn* ([x] (clojure.core/println x Hello, World!))))
</code>
<code>core.typed</code>による静的型チェックでは、全ての<code>var</code>が明示的に型付けされている必要があります。<br/>
上記では、<code>try-typed.core/foo</code>関数に型付けがされていないため、エラーになっています。</p>

<h2>varに型付けを行う</h2>

<p><code>clojure.core.typed/ann</code>で、varに型付けを行うことができます。<br/>
上記でエラーになった<code>try-typed.core/foo</code>に型付けしてみます。<br/>
<a href="https://gist.github.com/matstani/6420121">core.clj</a>
{% gist 6420121 core.clj %}
上記の例では、<code>try-typed.core/foo</code>に対し「<code>String</code>型の引数をとり<code>nil</code>を返す」という型情報を付与しています。<br/>
この状態で型チェックを行うと、<code>:ok</code>となります。
<code>
user=&gt; (check-ns 'try-typed.core)
Start collecting try-typed.core
Finished collecting try-typed.core
Collected 1 namespaces in 16.039067 msecs
Start checking try-typed.core
Checked try-typed.core in 65.01378 msecs
Checked 1 namespaces (approx. 8 lines) in 84.795137 msecs
:ok
</code></p>

<h2>型不一致エラー</h2>

<p><code>clojure.core.typed/ann</code>で指定した型付けと整合しない呼び出しがあった場合、エラーとして検出されます。<br/>
例) <a href="https://gist.github.com/matstani/6420121#file-core2-clj">core2.clj</a>
{% gist 6420121 core2.clj %}
```
user=> (check-ns 'try-typed.core)
Start collecting try-typed.core
Finished collecting try-typed.core
Collected 1 namespaces in 15.624342 msecs
Start checking try-typed.core
Checked try-typed.core in 33.318364 msecs
Type Error (try-typed.core:13:3) Type mismatch:</p>

<p>Expected:       String</p>

<p>Actual:         (Value 1.5)
in: (try-typed.core/foo 1.5)
```</p>

<h2>型情報の参照</h2>

<p><code>clojure.core.typed/cf</code>で型情報を参照できます。
<code>
user=&gt; (cf try-typed.core/foo)
(Fn [String -&gt; nil])
</code>
標準関数についても、ほとんどがライブラリ内で型付けされています。
<code>
user=&gt; (cf inc)
(Fn [AnyInteger -&gt; AnyInteger] [Number -&gt; Number])
</code>
自作関数と、標準関数の間で型の不整合があった場合には、エラーとして検出されます。<br/>
例) <a href="https://gist.github.com/matstani/6420121#file-core3-clj">core3.clj</a>
{% gist 6420121 core3.clj %}
```
user=> (check-ns 'try-typed.core)
Start collecting try-typed.core
Finished collecting try-typed.core
Collected 1 namespaces in 22.306404 msecs
Start checking try-typed.core
Checked try-typed.core in 36.899735 msecs
Type Error (try-typed.core:8:3) Static method clojure.lang.Numbers/inc could not be applied to arguments:</p>

<p>Domains:</p>

<pre><code>    AnyInteger
    Number
</code></pre>

<p>Arguments:</p>

<pre><code>    String
</code></pre>

<p>Ranges:</p>

<pre><code>    AnyInteger
    Number
</code></pre>

<p>with expected type:</p>

<pre><code>    AnyInteger
</code></pre>

<p>in: (clojure.lang.Numbers/inc s)
<code>
関数内で正しく型変換していると、チェックは`:ok`になります。  
例) [core4.clj](https://gist.github.com/matstani/6420121#file-core4-clj)
{% gist 6420121 core4.clj %}
</code>
user=> (check-ns 'try-typed.core)
Start collecting try-typed.core
Finished collecting try-typed.core
Collected 1 namespaces in 36.006706 msecs
Start checking try-typed.core
Checked try-typed.core in 38.304219 msecs
Checked 1 namespaces (approx. 9 lines) in 78.396396 msecs
:ok
```</p>

<h2>型付けの例</h2>

<h3>引数が複数</h3>

<p><code>
(ann my-add [Number, Number -&gt; Number])
(defn my-add [n1 n2]
  (+ n1 n2))
</code></p>

<h3>可変長引数</h3>

<p><code>
(ann my-add [Number * -&gt; Number])
(defn my-add [&amp; n]
  (apply + n))
</code></p>

<h3>シーケンス</h3>

<p><code>
(ann my-add [(Seqable Number) -&gt; Number])
(defn my-add [n]
  (apply + n))
</code></p>

<h3>Set</h3>

<p><code>
(ann my-filter [(Set AnyInteger) -&gt; (Seqable AnyInteger)])
(defn my-filter [n]
  (filter odd? n))
</code></p>

<h3>Map</h3>

<p><code>
(ann get-count [(Map clojure.lang.Symbol Number) -&gt; (U nil Number)])
(defn get-count [m]
  (m :count))
</code></p>

<h3>無名関数</h3>

<p>高階関数に無名関数を渡す場合、型付けが必要になる場合があるようです。
<code>clojure.core.typed/fn&gt;</code>による型付け
```
(ann inc-seq [Number, (Seqable Number) -> (Seqable Number)])
(defn inc-seq
  [i s]</p>

<pre><code>(map
   ; clojure.core.typed/fn&gt; は無名関数のパラメータに型情報を付加できる
   (fn&gt; [e :- Number] (+ i e))
   s))
</code></pre>

<p><code>
`clojure.core.typed/ann-form`による型付け
</code>
(ann inc-seq [Number, (Seqable Number) -> (Seqable Number)])
(defn inc-seq
  [i s]</p>

<pre><code>(map
   ; clojure.core.typed/ann-form&gt; は任意のフォームに型情報を付加できる
   (ann-form #(+ i %) [Number -&gt; Number])
   s))
</code></pre>

<p>```</p>

<h2>その他</h2>

<p>Clojureには標準で型ヒント(<a href="http://clojure.org/java_interop#Java%20Interop-Type%20Hints">type hinting</a>)と呼ばれる機能がありますが、Javaを呼び出す際のリフレクションを防ぐためのもので、<code>core.typed</code>のような、静的型チェックの機能ではありません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Clojure] ちょっと難しいシーケンス処理]]></title>
    <link href="http://matstani.github.com/blog/2013/08/02/difficult-sequences/"/>
    <updated>2013-08-02T18:06:00+09:00</updated>
    <id>http://matstani.github.com/blog/2013/08/02/difficult-sequences</id>
    <content type="html"><![CDATA[<p><a href="http://blog.safaribooksonline.com/2013/07/24/sequence-abstractions-in-clojure/">Sequence Abstractions in Clojure</a></p>

<p>上記のリンクはClojureのシーケンスに関する記事なのですが、"Difficult Sequences"のところが面白かったのでメモします。</p>

<p>Clojureでは、<code>map</code>、<code>filter</code>を始めとした豊富なシーケンス用関数がありますが、例えば「1つ前の要素を参照する」処理はどう書くのでしょうか。<br/>
手続き型言語では、以下のように記述できます。
```
v = [1 2 3 4 5];
for (i=1; i&lt;v.length; i++)</p>

<pre><code>print v[i] + v[i-1];
</code></pre>

<p>-> 3 5 7 9
```</p>

<p>この「1つ前の要素を参照する」処理をシーケンスで実現するために、まず「1つずらしたシーケンス」を考えてみます。
<code>
  [1 2 3 4 5]
[1 2 3 4 5]
</code>
すると、上下が重なっている部分が、「1つ前の要素」と「現在の要素」の組み合わせになっています。<br/>
Clojureのmap関数では、復数のシーケンスを同時に扱うことができます。
<code>
(map + [1 3] [2 4])
-&gt; (3 7)
</code>
渡したシーケンスの最初の要素同士、2番目の要素同士、がそれぞれ"+"されています。<br/>
「元のシーケンス」、「1つずらしたシーケンス」、を用意してmap関数に渡してやれば、目的の処理が実現できそうです。<br/>
「1つずらしたシーケンス」を得るには、<code>rest</code>関数が利用できます。
<code>
(def v [1 2 3 4 5])
(rest v)
-&gt; (2 3 4 5)
</code>
rest関数が返すのは、シーケンスの先頭以外を含むシーケンスです。<br/>
これらを組み合わせると目的の処理を実現できます。
<code>
(map + v (rest v))
-&gt; (3 5 7 9)
</code>
ここでは
<code>
v        -&gt; (1 2 3 4 5)
(rest v) -&gt; (2 3 4 5)
</code>
上記2つのシーケンスの重なっている要素同士の足し算"+"が行われ、目的が実現できています。<br/>
<code>map</code>関数に長さの異なるシーケンスを渡された場合、長いシーケンスの余り部分は無視されます。</p>
]]></content>
  </entry>
  
</feed>
